pipeline {
    agent any
    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_KEY')
        AWS_DEFAULT_REGION = 'eu-north-1'
        SONARQUBE_TOKEN = credentials('SONARQUBE_TOKEN')
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')
        TELEGRAM_BOT_TOKEN = credentials('TELEGRAM_BOT_TOKEN')
        TELEGRAM_CHAT_ID = credentials('TELEGRAM_CHAT_ID')
        CERT_PATH = "${WORKSPACE}/certificates"
    }

    stages {
        stage('Clean Workspace') {
            steps {
                deleteDir()
            }
        }
        stage('Checkout Code') {
            steps {
                git branch: 'main', url: 'git@github.com:oksesaneka22/kubiks.git'
            }
        }
        stage('Setup files') {
            steps {
                script {
                    sh 'mkdir -p $CERT_PATH'

                    // Load the certificate from Jenkins credentials
                    withCredentials([certificate(credentialsId: 'CERT', keystoreVariable: 'CERT_FILE')]) {
                        sh '''
                        # Extract private key
                        openssl pkcs12 -in "$CERT_FILE" -nocerts -nodes -passin pass: | \
                        awk '/-----BEGIN PRIVATE KEY-----/,/-----END PRIVATE KEY-----/' > "$CERT_PATH/private.pem"
                        
                        # Extract certificate and remove bag attributes
                        openssl pkcs12 -in "$CERT_FILE" -clcerts -nokeys -passin pass: | \
                        awk '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/' > "$CERT_PATH/origin.pem"
                        '''
                    }
                    sh 'git clone https://github.com/Kholod13/SoundScape.git --branch main Back'
                    sh 'mv Dockerfile-back ./Back/Dockerfile'
                    sh 'cp $CERT_PATH/origin.pem ./Back/origin.pem'
                    sh 'cp $CERT_PATH/private.pem ./Back/private.pem'
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                script {
                    def scannerHome = tool 'sonar-scanner'
                    withSonarQubeEnv() {
                      sh "cd Back && dotnet ${scannerHome}/SonarScanner.MSBuild.dll begin /k:\"Soundscape-back\""
                      sh "cd Back && dotnet build"
                      sh "cd Back && dotnet ${scannerHome}/SonarScanner.MSBuild.dll end"}
                      sh 'python3 Python/issues-back.py'
                }
            }
        }
        
        stage('Docker Build & Push') {
            steps {
                script{
                    sh 'docker build -t oksesaneka22/backend:${BUILD_NUMBER} ./Back'
                    sh 'docker push oksesaneka22/backend:${BUILD_NUMBER}'
                }
                
            }
        }
        stage('Determine Active Deployment') {
            steps {
                script {
                    env.activeDeployment = sh(script: "sudo kubectl get deployments -n todo-app -o json | jq -r '.items[] | select(.spec.template.spec.containers[0].image | startswith(\"oksesaneka22/backend:\")) | .metadata.name'", returnStdout: true).trim()
                    if (env.activeDeployment.contains("backend-blue")) {
                        env.NEW_DEPLOYMENT = "backend-green"
                    } else if (env.activeDeployment.contains("backend-green")) {
                        env.NEW_DEPLOYMENT = "backend-blue"
                    } else {
                        error "Error: Unable to determine active deployment"
                    }
                    echo "Active Deployment: ${env.activeDeployment}"
                    echo "New Deployment: ${env.NEW_DEPLOYMENT}"
                }
            }
        }
        stage('sed') {
            steps {
                script {
                    sh "cd Services && sed -i 's|image: oksesaneka22/backend:.*|image: oksesaneka22/backend:${BUILD_NUMBER}|' backend.yaml"
                    sh "cd Services && sed -i 's|image: oksesaneka22/backend:.*|image: oksesaneka22/backend:${BUILD_NUMBER}|' backend-blue.yaml"
                    sh "cd Services && sed -i 's|image: oksesaneka22/backend:.*|image: oksesaneka22/backend:${BUILD_NUMBER}|' backend-green.yaml"
                }
            }
        }
        stage('Switch Deployment') {
            steps {
                script {
                    if (env.NEW_DEPLOYMENT == "backend-blue") {
                        sh 'sudo kubectl apply -f Services/backend-blue.yaml'
                        sh 'sudo kubectl get deployments -n todo-app'
                        sh 'sudo kubectl delete deployment backend-green -n todo-app'
                        sh 'sudo kubectl get deployments -n todo-app'
                        sh 'sudo kubectl delete pods -l app=backend -n todo-app'
                    } else if (env.NEW_DEPLOYMENT == "backend-green") {
                        sh 'sudo kubectl apply -f Services/backend-green.yaml'
                        sh 'sudo kubectl get deployments -n todo-app'
                        sh 'sudo kubectl delete deployment backend-blue -n todo-app'
                        sh 'sudo kubectl get deployments -n todo-app'
                        sh 'sudo kubectl delete pods -l app=backend -n todo-app'
                    } else {
                        echo "Error: Unknown deployment"
                        echo "Active Deployment: ${env.ACTIVE_DEPLOYMENT}"
                    }
                }
            }
        }   
    }
    post {
        success {
            script {
                sh 'python3 Python/telegram.py'
            }
        }
        failure {
            script {
                sh 'python3 Python/error_alert.py'
            }
        }
    }
}
